# Java 内部类

#### 内容摘要

内部类，成员内部类，局部内部类

---

#### 内部类

* 定义在其他类的内部的类
* 注：外部：外部类外部；
* 访问特点：
  * **内部类可以直接访问外部类成员，包括私有成员**
  * 外部类要访问内部类成员，先要创建内部类对象
* 分类
  * **成员内部类**：成员变量平行
  * 局部内部类：方法中定义的内部类

#### 成员内部类 

* 外界访问内部类

  * 一般内部类不让外部类直接访问
  * 外部类里面：`内部类 变量名 = new 内部类()`
  * 外部类外面：`外部类.内部类 变量名 = 外部类对象.内部类对象`

  ```Java
  // 外部内内部
  Inner inner1 = new Inner();

  // 外部内外部
  Outer outer = new Outer();
  Outer.Inner inner2 = outer.new Inner();
  // 一行写法
  Outer.Inner inner3 = new Outer().new Inner(); // 匿名对象写法
  ```

* **普通的成员内部类对象都隐式的持有外部类对象引用**

  * 当外部类对象没有引用指向它，即将成为垃圾时
  * 内部类对象还隐式指向它，导致无法回收，可能造成内存泄漏
  * 一旦该内部类加了 static 修饰，那么内部类对象不再持有外部类对象的引用，可以规避

* **访问修饰符**

  * 不能修饰普通类，但可以修饰内部类

  * `private` 私有内部类

    * 外部无法访问 私有 内部类，无法创建对象
    * 保证数据安全性

  * `static` 静态内部类

    * 整个内部类类体变成静态环境，**只允许访问外部类中静态成员**
    * 内部类中非静态or静态成员，需要创建内部类对象去访问
      * 创建静态内部类对象 `Outer.Inner inner = new Outer.Inner();` 
    * 内部类中静态成员，可以通过 `外部类名.内部类名.成员名` 访问
    * 提高访问数据方便性

  * `private static ` 内部类

    ```Java	
    private static Node {
      int item;
      Node next;
    }
    ```

* **同名成员问题**

  * 在内部类中访问内部类同名成员 `this.i`
  * 在内部类中访问外部类同名成员 `Outer.this.i`
    * 这是种写法，在多层次嵌套中指明是哪个类的 `this`
    * 而不是静态调用

#### 局部内部类

* 定义在普通类，成员方法中的类
* **可以直接访问外部类成员**
* 只能在定义其的方法体内创建内部类对象，通过调用方法来使用局部内部类
* 局部内部类访问局部变量，只能访问 `final` 修饰的局部变量
  * 若没有 final 修饰，编译器会自动加上
  * 原因：方法已结束，局部变量就会被回收，但栈空间中内部类还没被回收，却还有方法访问局部变量中已被回收的局部变量，故局部变量应该设定为 final ，放在常量池内
* 不能用 `static` 修饰符

#### 匿名内部类

* 匿名对象：没有引用变量指向它，用完就变为垃圾，不能复用

#### 内部类补充

> 内部类可以实现实质上的多重继承：多个成员内部类继承多个类
>
> 多个接口有同名抽象方法，同时实现这几个接口，普通类只能重载一个方法，导致无法区分调用
>
> * 解决方案：用多个成员内部类实现这几个接口，分别重载方法