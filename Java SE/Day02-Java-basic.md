## Java 基础01

#### 内容摘要

关键字、标识符、注释、常量、数据类型、数值大小、运算符、边界问题、**有符号数**

---

#### 关键字

* Java 语言赋予特定含义的单词
* 字母全部小写
* goto const 作为保留字未被使用

#### 标识符

* 给类、接口、变量起名字时用的字符序列
* 组成规则：
  * 英文小写字母
  * 数字字符
  * $ 和 _
  * 如： HelloWorld    _982    $change
* 注意事项：
  * 不能以数字开头
  * 不能是 Java 中的关键字
  * **区分大小写**
* **实际开发中，标识符命名：见名知意，驼峰命名**
  * 类或接口：
    * 一个单词：首字母大写 Main Hello
    * 多个单词：每个单词首字母大写 HelloWorld JavaStudent
  * 方法：
    * 一个单词：首字母小写 main put add
    * 多个单词：第一个单词小写，之后每一个单词首字母大写 getValue getIntValue
  * 变量：
    * 一个单词：首字母小写 i sum count
    * 多个单词：第一个单词小写，之后每一个单词首字母大写 maxValue leftChild
  * 包（组织 Java 中的类，不同的类放到不同的包下：
    * 便于项目代码维护和管理
    * 解决类的命名冲突
    * 包名全部单词小写
    * 命名规则
      * 网络中，域名是唯一的，如：www.cskaoyan.com
      * **域名反转**来定义包名，如：com.cskaoyan.www

#### 注释

* 解释说明，对象是开发者

* 排错功能

* 注释方式

  ```Java
  // 单行注释，所在行内的内容，编译器都会忽略

  /* 
     多行注释，在多行注释符号之间的内容，编译器都会忽略
     多行注释不可嵌套
     Ctrl + Shift + /
     Command + Shift + ／
  */

  /**
  *  文档注释，和多行注释差不多
  *  可以直接将注释内容自动生成 java doc
  */
  ```

#### 常量

* 程序执行过程中其值不能发生改变
* 分类
  * 字面值常量
    * 整数常量
      * 十进制
        * 逢10进1，0 - 9
        * 123 = 1 * 10^2^ + 2 * 10 ^1^ + 3 * 10^0^
        * 每一位上所表示的实际的值，与权重和系数有关
        * 权重：随数位从0开始从由右向左逐位增1
      * 二进制
        * Java 中以 `0b `为前缀表示二进制数，如 0b1010
        * 世界上有10种人，一种是懂二进制的，一种是不懂二进制的
      * 八进制
        * Java 中以 `0 `为前缀表示八进制数，如 01010
        * 逢8进1，0 - 7
      * 十六进制
        * Java 中以 `0x`为前缀表示二进制数，如 0x1010
        * 逢16进1， 0 - 9 A B C D E F (0 -15)
      * 十进制转二进制
      * 八进制与二进制之间转换
        * 3位二进制可以转化为1位8进制
        * 111 = 7 , 110 = 6
      * 十六进制与二进制之间转换
        * 4位二进制可以转化为1位16进制
        * 1010 = A , 1011 = B 
    * **有符号数**，重点理解
      * 见下专题讲解
    * 字符常量
      * 如 'a' 'b' 'c'
    * 字符串产量
      * 如 "Hello world"  
    * 小数常量
      * 如 12.34  56.78
    * 布尔常量
      * 只有2个值 true false
    * 空常量
      * 只有1个值 null
  * 自定义常量（面向对象再讲）

#### 变量

* 在程序执行过程中，在某个范围（数据类型大小）内，其值可以发生改变的量

* 理解：一块内存空间

* 同一作用域中不能定义同名变量

  * Java 局部变量中的值必须初始化才能使用

* 定义变量

  ```Java
  // 数据类型 变量名 = 初始化值
  	int i = 1;

  // 对于小数常量默认类型是double
  	float f = 0.1f;

  // 布尔类型
  	boolean a = true;

  // a在码表中对应的值为97
  // 对于一个整数值常量，其默认为int
      System.out.println('97');// 输出 a
  	System.out.println(97);// 输出 97

  ```

#### 数据类型

* Java 是**强类型语言**

* 整数默认 int  小数默认 double

* 基本数据类型

  * 数值型
    * 整数类型（ short  int  long ）
    * 浮点类型（ float  double ） ：以科学计数法来表示，表示范围大很多
  * 字符型（ char ）：占2个字节，通过ASC II码表来将字符表示与其表示对应起来
  * 布尔型（ boolean ）：

* 引用数据类型

  * 类（ class ）
  * 接口（ interface ）
  * 数组（ [ ] ）

* 默认转换

  * 小类型 => 大类型

  * byte, short, char  => int => long => float => double

  * **byte, short, char 相互之间不转换，参与运算首先转换为int类型**

    ``` Java
    // 如，2个byte类型相加 会得到int类型
    	byte a = 2;//虽然整数常量默认是int型，但是编译器会隐式转换
    	byte b = 4;
    	byte c = a + b;// 编译错误，int = byte + byte 
    ```

* 强制转换由低到高截断处理

  ```Java
  byte b = (byte) 130;
  System.out.println(b);// 强制转换由低到高截断处理，b 输出为 -160，具体见下有符号数专题讲解
    
  //不是所有转换都会影响精确度
    float f = (float) 0.1;
  ```

  `+` 

  * 字符串拼接（参加运算的操作数至少有一个为字符串）
  * 加法操作

#### 数值大小

| 类型     | 占用存储空间     | 表示范围                          |
| ------ | ---------- | ----------------------------- |
| byte   | 1 字节   8 位 | -128 ~ 127   -2^7^ ~ 2^7^ - 1 |
| short  | 2 字节   16位 | -2^15^ ~ 2^15^ - 1            |
| int    | 4 字节   32位 | -2^31^ ~ 2^31^ - 1            |
| long   | 8 字节   64位 | -2^63^ ~ 2^63^ - 1            |
| float  | 4 字节       | -3.403E38 ~ 3.403E38          |
| double | 8 字节       | -1.798E308 ~ 1.798E308        |

#### 运算符

* 算术运算符

  * `/` ：当参与运算的两个操作数都是整数时，除法结果只保留整数部分

    * **整数除整数，只保留整数部分**

    ```Java
    double d1 = 1 / 2; // d1 的值为 0.0，整数除整数，只保留整数部分

    double d2 = 1.0 * 1 / 2; // d2 的值为 0.5，默认类型转化为double之后在运算
    ```

  * `%`：取余运算的结果的正负号取决于被取余数

  * `++` `--`：自增、自减运算符

    * 变量 ++ ：先进行表达式运算，再自增，自减
    * ++ 变量：先自增，自减，再进行表达式运算

* 赋值运算符

  * 见Day03

#### 边界问题

```Java
int maxValue = Integer.MAX_VALUE；
int minValue = Integer.MIN_VALUE;
int i = maxValue + 1;//超过最大值，得到 i == minValue
int j = minValue - 1;//超过最小值，得到 j == maxValue
```

* 数据溢出：最大值 + 1 = 最小值 
* 表现
  * 正数之和，越界得到负数
  * 负数之和，越界得到正数
* 边界问题

#### 其他

一个 Java 文件当中，只能定义一个 public 类，且该类的类名必须和 Java 文件的文件名相同

Java 虚拟机在执行的时候，是从 main 方法开始执行，即 入口函数



## 有符号数

#### 概念

* **Java 中数值是以 补码 的形式存储**
* 为了区别正负数，引入符号位，约定最高位为符号位：**0表示正数，1表示负数**
* 源码 = 符号位 + 真值（二进制）      如： 8 = 0100      -8 = 1100      -2 = 110 
* 反码：在源码的基础上，除符号位，各位取反，如 -2 = 110，反码为 101
  * **正数的反码和补码都是其本身，只需注意负数的反码和补码**
* **补码：在反码的基础上，末位加1**  
  * 如 源码（假设8位存储空间） -2 = 1000 0010 => 反码 1111 1101 =>补码 1111 1110
  * 正0 和 负0 的补码表示是相同的，把负0对应的补码表示拿出来表示另一个负数
  * 即 byte 范围 正：0 ~ 127  负： -128 ~ 0 ，负数比正数多表示一个数 最小那个数
* 补码 与 源码互补，即补码的补码就是源码
* 在计算机运算中，若直接用源码，符号和数值要分开算，**补码 **则可以直接参加运算

#### 示例

**强制转换由低到高截断处理**

```Java
/*
* 前提
* 1. 130 默认为 int 类型
* 2. byte 最多可表示 8 位二进制数，范围 -128 ~ 127，即 1111 1111 ～ 0111 1111
* 3. (byte) 强制转换为 byte 类型，由低到高强制转换会截断处理
* 4. int 类型可以表示 32 位二进制数
*/

byte b = (byte) 130; // = -126

/*
* 截断操作
* 1. 转换为二进制，写出源码，正负有别
* 2. 根据反码求出补码
* 3. 根据实际存储位数做截断处理，得到 新二进制 补码
* 4. 将 新二进制 补码 求补码即为 源码
* 5. 源码 再转换为 十进制，即为输出结果
*/

/*
* 截断操作
* 1. 130 = 128 + 2 = 2^7 + 2^1 = 1000 0010，源码：0 1000 0010
			此处技巧：将十进制分解为2的n次幂相加，即可以不用余数倒写法
* 2. 源码 0 1000 0010 ==> 反码 0 1000 0010 ==> 补码 0 1000 0010
			此处技巧：正数的反码和补码是其本身
* 3. 只保留 8 位，截断后 => 1000 0010
* 4. 1000 0010 => 反码 1111 1101 => 补码 1111 1110
* 5. 1 111 1110 = -（2^6 + 2^5 + 2^4 +2^3 +2^2 + 2^1) = -126
			此处技巧：只计算真值部分，即前7位
*/

```

#### 练习

```Java
byte b = (byte)300; // = 44
// 300 = 256 + 32 + 8 + 4 = 2^8 + 2^5 + 2^3 + 2^2 = 1 0010 1100 => 01 0010 1100
// 01 0010 1100 => 01 0010 1100 => 01 0010 1100
// ==> 截断后 0010 1100 ==> 其源码 0010 1100
// 0 010 1100 = 2^5 + 2^3 + 2^2 = 32 + 8 + 4 = 44

byte c = (byte) - 543; // = -31
//543 = 512 + 16 + 8 + 4 + 2 + 1 = 2^9 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0
//10 0001 1111 ==> 反码 11 1110 0000 ==> 补码 11 1110 0001
// 截断 1110 0001 ==> 其反码 1001 1110 ==> 其源码 1001 1111
// 1 001 1111 = - (2^4 + 2^3 + 2^2 + 2^1 + 2^0) = -31
```

#### 总结

1. 源码 = 符号位 + 真值，**转十进制只用计算真值部分**
2. 反码和源码互补，反码的反码就是源码
3. 十进制转二进制：将十进制分解为 2 的 n 次幂相加，可以不用余数倒写
4. 正数的反码和补码是其本身
5. 最后得到的源码只计算真值部分，再加符号
6. 十进制 => 二进制 源码 => 判断正负 => 写出反码 => 求出补码 => 截断 >> 新补码 => 求其源码 => 十进制