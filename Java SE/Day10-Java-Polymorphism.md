# Java 多态

#### 内容摘要

**多态**，**抽象类**，**接口**

------

#### 多态 *polymorphism*

> * 用同一个函数调用实现不同的操作方法
> * **重载** *overload*
>   * 任意类中都会发生，子类可以重载父类方法
>   * 同一类中参数不同的同名方法（编译时多态）
>   * 根据使用场景，编译器能确定该执行哪个参数的方法
>   * 方法重载
>     * 方法签名 *signature*：方法名 + 参数列表
>     * **不能声明签名相同的两个方法**
> * **覆盖** *override*
>   * 继承关系的类中才会发生
>   * 父类和子类之间的参数相同的同名方法（运行时多态）
>   * 子类的方法会覆盖父类的方法
>   * 只有程序在内存中运行时，虚拟机才知道该调用哪一个（子类 or 父类）的方法

* 同一个事物（相同方法名），在不同时空表现出来的不同形态（不同方法体）

* 发生前提：

  * 继承关系
  * 方法覆盖
  * 父类引用指向子类实例

* 成员访问特点：

  * 成员变量：编译看左边（**父类引用类型**）；运行看左边（父类中成员变量）
  * 成员方法：编译看左边（**父类引用类型**）；运行看右边（子类的覆盖方法）
  * **隐藏**：子类成员变量与父类成员变量同名，父类成员变量隐藏
  * **覆盖**：子类成员方法与父类成员方法方法签名相同，父类成员方法覆盖
  * 所以，可以通过覆盖方法调用子类成员变量

* 优势

  * 提高代码可维护性
  * 提高代码**可扩展性**

* 弊端

  * 不能使用子类特有的功能

  * 解决方法：

    * 创建子类对象调用子类方法

    * 类型强转，父类引用强转为子类引用（子类引用指向子类对象）

      ```Java
      // 子类类型转换为父类类型，父类引用指向子类对象，即向上转型
      Animal animal = new Dog(); // 向上转型
      Dog d = (Dog) animal; // 向下转型
      d.bite();

      // 父类引用指向父类对象，再转为子类，编译能成功，运行报错 java.lang.ClassCastException
      Animal animal = new Animal(); 
      Dog d = (Dog) animal; // 向下转型
      d.bite();
      ```

* 类型转换

  * 向上转型：
    * 子类类型，转化为父类类型，`Animal animal = new Dog();`
  * 向下转型：
    * 父类类型，转化为子类类型，`Dod d = (Dog) new Animal();`
  * `instanceof` 操作符
    * `对象 instanceof 类`
    * 判断 `对象` 是否是 `类` 的实例
    * `null` 与所有引用类型兼容，但不是任何类型实例
    * ` null instanceof 类 == false `
  * **向下转型有风险**
    * 编译正常通过，运行时会正常运行，遇到转型错误，才会报错，运行异常
    * 原因
      * 子类对象内存中有父类对象，可以转换，向上转型，不会出错
      * 父类对象内存中没有子类对象，不能转换，会出错
    * **转型前先判断**  `instanceof`

  ```Java
  /*
  向上转型：new Dog() 是一个子类对象，其中包含子类对象和父类对象
          可以向上转型 Animal animal = (Animal) new Dog();
          即 父类引用指向子类对象

  向下转型：父类引用指向子类对象时，可以向下转型
          Dog dog = (Dog) animal;

  		危险情况：new Animal() 是一个父类对象，其中只有父类对象
          向下转型时 Dog d = (Dog) new Animal();
          会报错 java.lang.ClassCastException

  ClassCastException 异常原因：将一个父类对象强制转换为子类类型
  */
  ```

#### 子类多态内存图

```Java
class Animal {
  String name = "animal";
  
  public void say() {
    System.out.println(name + " says");
  }
}

class Dog extends Animal {
  String name = "dog";
  public void say() {
    System.out.println(name + "says")
  }
}

public class Main {
  public static void main(String[] args) {
    Animal animal = new Dog();
    animal.name; // 输出 animal 父类成员变量被隐藏，但左边引用类型为父类，仍能拿到父类成员变量
    animal.say(); // 输出 dog says 父类成员方法被覆盖，运行的是子类覆盖方法体
  }
}
```

> 成员访问特点：
>
> * 成员变量：编译看左边（**父类引用类型**）；运行看左边（父类中成员变量）
> * 成员方法：编译看左边（**父类引用类型**）；运行看右边（子类的覆盖方法）
> * **隐藏**：子类成员变量与父类成员变量同名，父类成员变量隐藏
> * **覆盖**：子类成员方法与父类成员方法方法签名相同，父类成员方法覆盖
> * 所以，可以通过覆盖方法调用子类成员变量

![子类多态内存图（局部）](http://on-img.com/chart_image/5a583d27e4b0332f152a1dd1.png)

#### 抽象类 *abstract*

* `abstract`
  * 抽象类、抽象方法
    * 抽象类可以没有抽象方法
    * 抽象方法必须要在抽象类中才能定义
  * 抽象方法没有方法体 没有 `{}`
    * `abstract void show();`
  * **抽象类本身不能实例化，只能通过子类实例化**
    * 其子类可以是实现抽象方法的普通类，可以实例化
    * 其子类也可以是没有实现抽象方法的抽象类，不可以实例化
    * 当一个普通类被定义为抽象类，目的就是禁止实例化
* 抽象类中成员特点
  * 抽象类中可以有构造方法，用于子类访问父类数据的初始化
  * 包含普通成员变量（常量、变量，和普通类没区别）
  * 成员方法（普通方法、抽象方法）
* 抽象类一般作为框架，简化和限制子类设计
  * **强制子类覆盖实现所有抽象方法**，可以复用或覆盖普通方法
  * 抽象类的实例化天然满足**多态**条件

#### 接口 *interface*

* 一个**完全抽象**的**类**，所有的方法都是**抽象方法**
* `interface` 声明
  * `interface 接口名 {} ` 
  * **不能直接实例化，只能通过实现了该接口的子类来实例化**
* `implements` 实现
  * `class 类名 implements 接口名 {}`
  * 实现接口的类可以是抽象类，也可以是普通类
  * 实现了接口的类之间的关系类似继承关系
  * 接口的实例化天然满足**多态**条件
* 接口中的成员特点
  * 成员访问修饰符默认   `public`（隐藏），不能指定其他访问修饰符
  * 成员变量默认 `static final` （隐藏），必须显式初始化
  * 所有的成员方法都是**抽象方法**
  * 接口中没有构造方法
* 类、接口关系，继承角度
  * 类和类，可以继承
  * 类和接口
    * 普通类可以实现接口，成为接口的子类
    * 抽象类可以实现接口，不用实现接口的方法
    * 类只能继承一个类，但可以实现一个或多个接口
    * `class A extends B implements C, D, E {}`
  * 接口和接口
    * 一个接口可以继承多个父接口，**多重继承**
      * `interface A extends B, C, D {}`
      * **父接口成员变量隐藏**：子接口与父接口同名域，但可以通过接口名访问成员变量(静态)
    * 接口不能继承普通类
* 接口中的方法可以重载，可以覆盖（无意义）
* **接口引用指向实现类实例，多态，只能看到接口成员方法，看不到实现类全部**

#### JDK 8  *interface*

* 8 以前成员 `public` 方法：`void method();`


* `default` 方法：`default void method() {}`
  * 类似抽象类
  * 必须要有方法体，在接口中默认实现，不强制所有子类一定要覆盖该方法
* 8 以前将工具方法与类本身定义分离
* `static` 方法：`static void method() {}`
  * 被当作工具类型来用
  * 将工具方法与类定义重新结合，接口中用静态方法来定义